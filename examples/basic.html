<!doctype html>
<html>

	<head>
		<meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
		<script src="vendor/three.101.min.js"></script>	
		<script src="../dist/THREEAR.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>

		<!-- <script src="three/js/loaders/GLTF2Loader.js"></script> -->
<script src='https://cdn.jsdelivr.net/gh/mrdoob/three.js@r92/examples/js/loaders/GLTFLoader.js'></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js" integrity="sha512-yNJzAsg5JyP91u+sLHlUDULMBd3hmEiVkYeeN1cQBKaLZ7EyT6oH2u5THNIRM2Fu6VKcZJv+F/QAp1h/qzy9Ow==" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"></script>
<script src='https://threejs.org/examples/js/controls/OrbitControls.js'></script>

		
		<title>MOONSTACKS</title>
		<!-- Bind window error for error handling -->
		<script>
			// window.addEventListener('error', function(event) {
			// 	alert("ERROR: " + event.message + " at " + event.filename + " : " + event.lineno + " : " + event.colno);
			// });
		</script>
	</head>

	<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
		<script>











// // /// / / / / // /  // 


var GLTFLoader = ( function () {

function GLTFLoader( manager ) {

	THREE.Loader.call( this, manager );

	this.dracoLoader = null;
	this.ddsLoader = null;

}

GLTFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {

	constructor: GLTFLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = THREE.LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		scope.manager.itemStart( url );

		var _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		var loader = new THREE.FileLoader( scope.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		if ( scope.crossOrigin === 'use-credentials' ) {

			loader.setWithCredentials( true );

		}

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	},

	setDRACOLoader: function ( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	},

	setDDSLoader: function ( ddsLoader ) {

		this.ddsLoader = ddsLoader;
		return this;

	},

	parse: function ( data, path, onLoad, onError ) {

		var content;
		var extensions = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			var magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		var json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		if ( json.extensionsUsed ) {

			for ( var i = 0; i < json.extensionsUsed.length; ++ i ) {

				var extensionName = json.extensionsUsed[ i ];
				var extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
						extensions[ extensionName ] = new GLTFLightsExtension( json );
						break;

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.MSFT_TEXTURE_DDS:
						extensions[ extensionName ] = new GLTFTextureDDSExtension( this.ddsLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		var parser = new GLTFParser( json, extensions, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			manager: this.manager

		} );

		parser.parse( onLoad, onError );

	}

} );

/* GLTFREGISTRY */

function GLTFRegistry() {

	var objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

var EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
};

/**
 * DDS Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
 *
 */
function GLTFTextureDDSExtension( ddsLoader ) {

	if ( ! ddsLoader ) {

		throw new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );

	}

	this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
	this.ddsLoader = ddsLoader;

}

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
function GLTFLightsExtension( json ) {

	this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

	var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};
	this.lightDefs = extension.lights || [];

}

GLTFLightsExtension.prototype.loadLight = function ( lightIndex ) {

	var lightDef = this.lightDefs[ lightIndex ];
	var lightNode;

	var color = new THREE.Color( 0xffffff );
	if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

	var range = lightDef.range !== undefined ? lightDef.range : 0;

	switch ( lightDef.type ) {

		case 'directional':
			lightNode = new THREE.DirectionalLight( color );
			lightNode.target.position.set( 0, 0, - 1 );
			lightNode.add( lightNode.target );
			break;

		case 'point':
			lightNode = new THREE.PointLight( color );
			lightNode.distance = range;
			break;

		case 'spot':
			lightNode = new THREE.SpotLight( color );
			lightNode.distance = range;
			// Handle spotlight properties.
			lightDef.spot = lightDef.spot || {};
			lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
			lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
			lightNode.angle = lightDef.spot.outerConeAngle;
			lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
			lightNode.target.position.set( 0, 0, - 1 );
			lightNode.add( lightNode.target );
			break;

		default:
			throw new Error( 'THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".' );

	}

	// Some lights (e.g. spot) default to a position other than the origin. Reset the position
	// here, because node-level parsing will only override position if explicitly specified.
	lightNode.position.set( 0, 0, 0 );

	lightNode.decay = 2;

	if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

	lightNode.name = lightDef.name || ( 'light_' + lightIndex );

	return Promise.resolve( lightNode );

};

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
function GLTFMaterialsUnlitExtension() {

	this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

}

GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {

	return THREE.MeshBasicMaterial;

};

GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {

	var pending = [];

	materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
	materialParams.opacity = 1.0;

	var metallicRoughness = materialDef.pbrMetallicRoughness;

	if ( metallicRoughness ) {

		if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

			var array = metallicRoughness.baseColorFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( metallicRoughness.baseColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

		}

	}

	return Promise.all( pending );

};

/* BINARY EXTENSION */
var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

function GLTFBinaryExtension( data ) {

	this.name = EXTENSIONS.KHR_BINARY_GLTF;
	this.content = null;
	this.body = null;

	var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

	this.header = {
		magic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
		version: headerView.getUint32( 4, true ),
		length: headerView.getUint32( 8, true )
	};

	if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

		throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

	} else if ( this.header.version < 2.0 ) {

		throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

	}

	var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
	var chunkIndex = 0;

	while ( chunkIndex < chunkView.byteLength ) {

		var chunkLength = chunkView.getUint32( chunkIndex, true );
		chunkIndex += 4;

		var chunkType = chunkView.getUint32( chunkIndex, true );
		chunkIndex += 4;

		if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

			var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
			this.content = THREE.LoaderUtils.decodeText( contentArray );

		} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

			var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
			this.body = data.slice( byteOffset, byteOffset + chunkLength );

		}

		// Clients must ignore chunks with unknown types.

		chunkIndex += chunkLength;

	}

	if ( this.content === null ) {

		throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
function GLTFDracoMeshCompressionExtension( json, dracoLoader ) {

	if ( ! dracoLoader ) {

		throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

	}

	this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
	this.json = json;
	this.dracoLoader = dracoLoader;

}

GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {

	var json = this.json;
	var dracoLoader = this.dracoLoader;
	var bufferViewIndex = primitive.extensions[ this.name ].bufferView;
	var gltfAttributeMap = primitive.extensions[ this.name ].attributes;
	var threeAttributeMap = {};
	var attributeNormalizedMap = {};
	var attributeTypeMap = {};

	for ( var attributeName in gltfAttributeMap ) {

		var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

		threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

	}

	for ( attributeName in primitive.attributes ) {

		var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

		if ( gltfAttributeMap[ attributeName ] !== undefined ) {

			var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
			var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			attributeTypeMap[ threeAttributeName ] = componentType;
			attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

		}

	}

	return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

		return new Promise( function ( resolve ) {

			dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

				for ( var attributeName in geometry.attributes ) {

					var attribute = geometry.attributes[ attributeName ];
					var normalized = attributeNormalizedMap[ attributeName ];

					if ( normalized !== undefined ) attribute.normalized = normalized;

				}

				resolve( geometry );

			}, threeAttributeMap, attributeTypeMap );

		} );

	} );

};

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
function GLTFTextureTransformExtension() {

	this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

}

GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {

	texture = texture.clone();

	if ( transform.offset !== undefined ) {

		texture.offset.fromArray( transform.offset );

	}

	if ( transform.rotation !== undefined ) {

		texture.rotation = transform.rotation;

	}

	if ( transform.scale !== undefined ) {

		texture.repeat.fromArray( transform.scale );

	}

	if ( transform.texCoord !== undefined ) {

		console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

	}

	texture.needsUpdate = true;

	return texture;

};

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */
function GLTFMaterialsPbrSpecularGlossinessExtension() {

	return {

		name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

		specularGlossinessParams: [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity',
			'refractionRatio',
		],

		getMaterialType: function () {

			return THREE.ShaderMaterial;

		},

		extendParams: function ( materialParams, materialDef, parser ) {

			var pbrSpecularGlossiness = materialDef.extensions[ this.name ];

			var shader = THREE.ShaderLib[ 'standard' ];

			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			var specularMapParsFragmentChunk = [
				'#ifdef USE_SPECULARMAP',
				'	uniform sampler2D specularMap;',
				'#endif'
			].join( '\n' );

			var glossinessMapParsFragmentChunk = [
				'#ifdef USE_GLOSSINESSMAP',
				'	uniform sampler2D glossinessMap;',
				'#endif'
			].join( '\n' );

			var specularMapFragmentChunk = [
				'vec3 specularFactor = specular;',
				'#ifdef USE_SPECULARMAP',
				'	vec4 texelSpecular = texture2D( specularMap, vUv );',
				'	texelSpecular = sRGBToLinear( texelSpecular );',
				'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	specularFactor *= texelSpecular.rgb;',
				'#endif'
			].join( '\n' );

			var glossinessMapFragmentChunk = [
				'float glossinessFactor = glossiness;',
				'#ifdef USE_GLOSSINESSMAP',
				'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
				'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	glossinessFactor *= texelGlossiness.a;',
				'#endif'
			].join( '\n' );

			var lightPhysicalFragmentChunk = [
				'PhysicalMaterial material;',
				'material.diffuseColor = diffuseColor.rgb;',
				'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',
				'material.specularColor = specularFactor.rgb;',
			].join( '\n' );

			var fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

			delete uniforms.roughness;
			delete uniforms.metalness;
			delete uniforms.roughnessMap;
			delete uniforms.metalnessMap;

			uniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) };
			uniforms.glossiness = { value: 0.5 };
			uniforms.specularMap = { value: null };
			uniforms.glossinessMap = { value: null };

			materialParams.vertexShader = shader.vertexShader;
			materialParams.fragmentShader = fragmentShader;
			materialParams.uniforms = uniforms;
			materialParams.defines = { 'STANDARD': '' };

			materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			var pending = [];

			if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

				var array = pbrSpecularGlossiness.diffuseFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

			}

			materialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );
			materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
			materialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );

			if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

				materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

			}

			if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

				var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
				pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
				pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

			}

			return Promise.all( pending );

		},

		createMaterial: function ( params ) {

			// setup material properties based on MeshStandardMaterial for Specular-Glossiness

			var material = new THREE.ShaderMaterial( {
				defines: params.defines,
				vertexShader: params.vertexShader,
				fragmentShader: params.fragmentShader,
				uniforms: params.uniforms,
				fog: true,
				lights: true,
				opacity: params.opacity,
				transparent: params.transparent
			} );

			material.isGLTFSpecularGlossinessMaterial = true;

			material.color = params.color;

			material.map = params.map === undefined ? null : params.map;

			material.lightMap = null;
			material.lightMapIntensity = 1.0;

			material.aoMap = params.aoMap === undefined ? null : params.aoMap;
			material.aoMapIntensity = 1.0;

			material.emissive = params.emissive;
			material.emissiveIntensity = 1.0;
			material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;

			material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
			material.bumpScale = 1;

			material.normalMap = params.normalMap === undefined ? null : params.normalMap;

			if ( params.normalScale ) material.normalScale = params.normalScale;

			material.displacementMap = null;
			material.displacementScale = 1;
			material.displacementBias = 0;

			material.specularMap = params.specularMap === undefined ? null : params.specularMap;
			material.specular = params.specular;

			material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
			material.glossiness = params.glossiness;

			material.alphaMap = null;

			material.envMap = params.envMap === undefined ? null : params.envMap;
			material.envMapIntensity = 1.0;

			material.refractionRatio = 0.98;

			material.extensions.derivatives = true;

			return material;

		},

		/**
		 * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
		 * copy only properties it knows about or inherits, and misses many properties that would
		 * normally be defined by MeshStandardMaterial.
		 *
		 * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
		 * loading a glTF model, but cloning later (e.g. by the user) would require these changes
		 * AND also updating `.onBeforeRender` on the parent mesh.
		 *
		 * @param  {THREE.ShaderMaterial} source
		 * @return {THREE.ShaderMaterial}
		 */
		cloneMaterial: function ( source ) {

			var target = source.clone();

			target.isGLTFSpecularGlossinessMaterial = true;

			var params = this.specularGlossinessParams;

			for ( var i = 0, il = params.length; i < il; i ++ ) {

				var value = source[ params[ i ] ];
				target[ params[ i ] ] = ( value && value.isColor ) ? value.clone() : value;

			}

			return target;

		},

		// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
		refreshUniforms: function ( renderer, scene, camera, geometry, material ) {

			if ( material.isGLTFSpecularGlossinessMaterial !== true ) {

				return;

			}

			var uniforms = material.uniforms;
			var defines = material.defines;

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value.copy( material.color );
			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.glossinessMap ) {

				uvScaleMap = material.glossinessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;
				uniforms.envMapIntensity.value = material.envMapIntensity;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = renderer.properties.get( material.envMap ).__maxMipLevel;

			}

			uniforms.specular.value.copy( material.specular );
			uniforms.glossiness.value = material.glossiness;

			uniforms.glossinessMap.value = material.glossinessMap;

			uniforms.emissiveMap.value = material.emissiveMap;
			uniforms.bumpMap.value = material.bumpMap;
			uniforms.normalMap.value = material.normalMap;

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

			if ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {

				defines.USE_GLOSSINESSMAP = '';
				// set USE_ROUGHNESSMAP to enable vUv
				defines.USE_ROUGHNESSMAP = '';

			}

			if ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {

				delete defines.USE_GLOSSINESSMAP;
				delete defines.USE_ROUGHNESSMAP;

			}

		}

	};

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
function GLTFMeshQuantizationExtension() {

	this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	THREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

GLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );
GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {

	// Copies a sample value to the result buffer. See description of glTF
	// CUBICSPLINE values layout in interpolate_() function below.

	var result = this.resultBuffer,
		values = this.sampleValues,
		valueSize = this.valueSize,
		offset = index * valueSize * 3 + valueSize;

	for ( var i = 0; i !== valueSize; i ++ ) {

		result[ i ] = values[ offset + i ];

	}

	return result;

};

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	var result = this.resultBuffer;
	var values = this.sampleValues;
	var stride = this.valueSize;

	var stride2 = stride * 2;
	var stride3 = stride * 3;

	var td = t1 - t0;

	var p = ( t - t0 ) / td;
	var pp = p * p;
	var ppp = pp * p;

	var offset1 = i1 * stride3;
	var offset0 = offset1 - stride3;

	var s2 = - 2 * ppp + 3 * pp;
	var s3 = ppp - pp;
	var s0 = 1 - s2;
	var s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( var i = 0; i !== stride; i ++ ) {

		var p0 = values[ offset0 + i + stride ]; // splineVertex_k
		var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

var WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

var WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

var WEBGL_FILTERS = {
	9728: THREE.NearestFilter,
	9729: THREE.LinearFilter,
	9984: THREE.NearestMipmapNearestFilter,
	9985: THREE.LinearMipmapNearestFilter,
	9986: THREE.NearestMipmapLinearFilter,
	9987: THREE.LinearMipmapLinearFilter
};

var WEBGL_WRAPPINGS = {
	33071: THREE.ClampToEdgeWrapping,
	33648: THREE.MirroredRepeatWrapping,
	10497: THREE.RepeatWrapping
};

var WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

var ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

var PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

var INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
							// keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: THREE.InterpolateLinear,
	STEP: THREE.InterpolateDiscrete
};

var ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

var MIME_TYPE_FORMATS = {
	'image/png': THREE.RGBAFormat,
	'image/jpeg': THREE.RGBFormat
};

/* UTILITY FUNCTIONS */

function resolveURL( url, path ) {

	// Invalid URL
	if ( typeof url !== 'string' || url === '' ) return '';

	// Host Relative URL
	if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

		path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

	}

	// Absolute URL http://,https://,//
	if ( /^(https?:)?\/\//i.test( url ) ) return url;

	// Data URI
	if ( /^data:.*,.*$/i.test( url ) ) return url;

	// Blob URL
	if ( /^blob:.*$/i.test( url ) ) return url;

	// Relative URL
	return path + url;

}

var defaultMaterial;

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial() {

	defaultMaterial = defaultMaterial || new THREE.MeshStandardMaterial( {
		color: 0xFFFFFF,
		emissive: 0x000000,
		metalness: 1,
		roughness: 1,
		transparent: false,
		depthTest: true,
		side: THREE.FrontSide
	} );

	return defaultMaterial;

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( var name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {THREE.BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<THREE.BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	var hasMorphPosition = false;
	var hasMorphNormal = false;

	for ( var i = 0, il = targets.length; i < il; i ++ ) {

		var target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;

		if ( hasMorphPosition && hasMorphNormal ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );

	var pendingPositionAccessors = [];
	var pendingNormalAccessors = [];

	for ( var i = 0, il = targets.length; i < il; i ++ ) {

		var target = targets[ i ];

		if ( hasMorphPosition ) {

			var pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			var pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors )
	] ).then( function ( accessors ) {

		var morphPositions = accessors[ 0 ];
		var morphNormals = accessors[ 1 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {THREE.Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		var targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( var i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	var geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
			+ ':' + dracoExtension.indices
			+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	var attributesKey = '';

	var keys = Object.keys( attributes ).sort();

	for ( var i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

/* GLTF PARSER */

function GLTFParser( json, extensions, options ) {

	this.json = json || {};
	this.extensions = extensions || {};
	this.options = options || {};

	// loader object cache
	this.cache = new GLTFRegistry();

	// BufferGeometry caching
	this.primitiveCache = {};

	this.textureLoader = new THREE.TextureLoader( this.options.manager );
	this.textureLoader.setCrossOrigin( this.options.crossOrigin );

	this.fileLoader = new THREE.FileLoader( this.options.manager );
	this.fileLoader.setResponseType( 'arraybuffer' );

	if ( this.options.crossOrigin === 'use-credentials' ) {

		this.fileLoader.setWithCredentials( true );

	}

}

GLTFParser.prototype.parse = function ( onLoad, onError ) {

	var parser = this;
	var json = this.json;
	var extensions = this.extensions;

	// Clear the loader cache
	this.cache.removeAll();

	// Mark the special nodes/meshes in json for efficient parse
	this.markDefs();

	Promise.all( [

		this.getDependencies( 'scene' ),
		this.getDependencies( 'animation' ),
		this.getDependencies( 'camera' ),

	] ).then( function ( dependencies ) {

		var result = {
			scene: dependencies[ 0 ][ json.scene || 0 ],
			scenes: dependencies[ 0 ],
			animations: dependencies[ 1 ],
			cameras: dependencies[ 2 ],
			asset: json.asset,
			parser: parser,
			userData: {}
		};

		addUnknownExtensionsToUserData( extensions, result, json );

		assignExtrasToUserData( result, json );

		onLoad( result );

	} ).catch( onError );

};

/**
 * Marks the special nodes/meshes in json for efficient parse.
 */
GLTFParser.prototype.markDefs = function () {

	var nodeDefs = this.json.nodes || [];
	var skinDefs = this.json.skins || [];
	var meshDefs = this.json.meshes || [];

	var meshReferences = {};
	var meshUses = {};

	// Nothing in the node definition indicates whether it is a Bone or an
	// Object3D. Use the skins' joint references to mark bones.
	for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

		var joints = skinDefs[ skinIndex ].joints;

		for ( var i = 0, il = joints.length; i < il; i ++ ) {

			nodeDefs[ joints[ i ] ].isBone = true;

		}

	}

	// Meshes can (and should) be reused by multiple nodes in a glTF asset. To
	// avoid having more than one THREE.Mesh with the same name, count
	// references and rename instances below.
	//
	// Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

		var nodeDef = nodeDefs[ nodeIndex ];

		if ( nodeDef.mesh !== undefined ) {

			if ( meshReferences[ nodeDef.mesh ] === undefined ) {

				meshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;

			}

			meshReferences[ nodeDef.mesh ] ++;

			// Nothing in the mesh definition indicates whether it is
			// a SkinnedMesh or Mesh. Use the node's mesh reference
			// to mark SkinnedMesh if node has skin.
			if ( nodeDef.skin !== undefined ) {

				meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

			}

		}

	}

	this.json.meshReferences = meshReferences;
	this.json.meshUses = meshUses;

};

/**
 * Requests the specified dependency asynchronously, with caching.
 * @param {string} type
 * @param {number} index
 * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}
 */
GLTFParser.prototype.getDependency = function ( type, index ) {

	var cacheKey = type + ':' + index;
	var dependency = this.cache.get( cacheKey );

	if ( ! dependency ) {

		switch ( type ) {

			case 'scene':
				dependency = this.loadScene( index );
				break;

			case 'node':
				dependency = this.loadNode( index );
				break;

			case 'mesh':
				dependency = this.loadMesh( index );
				break;

			case 'accessor':
				dependency = this.loadAccessor( index );
				break;

			case 'bufferView':
				dependency = this.loadBufferView( index );
				break;

			case 'buffer':
				dependency = this.loadBuffer( index );
				break;

			case 'material':
				dependency = this.loadMaterial( index );
				break;

			case 'texture':
				dependency = this.loadTexture( index );
				break;

			case 'skin':
				dependency = this.loadSkin( index );
				break;

			case 'animation':
				dependency = this.loadAnimation( index );
				break;

			case 'camera':
				dependency = this.loadCamera( index );
				break;

			case 'light':
				dependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index );
				break;

			default:
				throw new Error( 'Unknown type: ' + type );

		}

		this.cache.add( cacheKey, dependency );

	}

	return dependency;

};

/**
 * Requests all dependencies of the specified type asynchronously, with caching.
 * @param {string} type
 * @return {Promise<Array<Object>>}
 */
GLTFParser.prototype.getDependencies = function ( type ) {

	var dependencies = this.cache.get( type );

	if ( ! dependencies ) {

		var parser = this;
		var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

		dependencies = Promise.all( defs.map( function ( def, index ) {

			return parser.getDependency( type, index );

		} ) );

		this.cache.add( type, dependencies );

	}

	return dependencies;

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
 * @param {number} bufferIndex
 * @return {Promise<ArrayBuffer>}
 */
GLTFParser.prototype.loadBuffer = function ( bufferIndex ) {

	var bufferDef = this.json.buffers[ bufferIndex ];
	var loader = this.fileLoader;

	if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

		throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

	}

	// If present, GLB container is required to be the first buffer.
	if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

		return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

	}

	var options = this.options;

	return new Promise( function ( resolve, reject ) {

		loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

			reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

		} );

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
 * @param {number} bufferViewIndex
 * @return {Promise<ArrayBuffer>}
 */
GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {

	var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

	return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

		var byteLength = bufferViewDef.byteLength || 0;
		var byteOffset = bufferViewDef.byteOffset || 0;
		return buffer.slice( byteOffset, byteOffset + byteLength );

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
 * @param {number} accessorIndex
 * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}
 */
GLTFParser.prototype.loadAccessor = function ( accessorIndex ) {

	var parser = this;
	var json = this.json;

	var accessorDef = this.json.accessors[ accessorIndex ];

	if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

		// Ignore empty accessors, which may be used to declare runtime
		// information about attributes coming from another source (e.g. Draco
		// compression extension).
		return Promise.resolve( null );

	}

	var pendingBufferViews = [];

	if ( accessorDef.bufferView !== undefined ) {

		pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

	} else {

		pendingBufferViews.push( null );

	}

	if ( accessorDef.sparse !== undefined ) {

		pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
		pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

	}

	return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

		var bufferView = bufferViews[ 0 ];

		var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
		var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

		// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
		var elementBytes = TypedArray.BYTES_PER_ELEMENT;
		var itemBytes = elementBytes * itemSize;
		var byteOffset = accessorDef.byteOffset || 0;
		var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
		var normalized = accessorDef.normalized === true;
		var array, bufferAttribute;

		// The buffer is not interleaved if the stride is the item size in bytes.
		if ( byteStride && byteStride !== itemBytes ) {

			// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
			// This makes sure that IBA.count reflects accessor.count properly
			var ibSlice = Math.floor( byteOffset / byteStride );
			var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
			var ib = parser.cache.get( ibCacheKey );

			if ( ! ib ) {

				array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

				// Integer parameters to IB/IBA are in array elements, not bytes.
				ib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );

				parser.cache.add( ibCacheKey, ib );

			}

			bufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

		} else {

			if ( bufferView === null ) {

				array = new TypedArray( accessorDef.count * itemSize );

			} else {

				array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

			}

			bufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );

		}

		// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
		if ( accessorDef.sparse !== undefined ) {

			var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
			var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

			var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
			var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

			var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
			var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

			if ( bufferView !== null ) {

				// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
				bufferAttribute = new THREE.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

			}

			for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {

				var index = sparseIndices[ i ];

				bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
				if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
				if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
				if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
				if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

			}

		}

		return bufferAttribute;

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
 * @param {number} textureIndex
 * @return {Promise<THREE.Texture>}
 */
GLTFParser.prototype.loadTexture = function ( textureIndex ) {

	var parser = this;
	var json = this.json;
	var options = this.options;
	var textureLoader = this.textureLoader;

	var URL = window.URL || window.webkitURL;

	var textureDef = json.textures[ textureIndex ];

	var textureExtensions = textureDef.extensions || {};

	var source;

	if ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {

		source = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];

	} else {

		source = json.images[ textureDef.source ];

	}

	var sourceURI = source.uri;
	var isObjectURL = false;

	if ( source.bufferView !== undefined ) {

		// Load binary image data from bufferView, if provided.

		sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

			isObjectURL = true;
			var blob = new Blob( [ bufferView ], { type: source.mimeType } );
			sourceURI = URL.createObjectURL( blob );
			return sourceURI;

		} );

	}

	return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

		// Load Texture resource.

		var loader = options.manager.getHandler( sourceURI );

		if ( ! loader ) {

			loader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]
				? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader
				: textureLoader;

		}

		return new Promise( function ( resolve, reject ) {

			loader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );

		} );

	} ).then( function ( texture ) {

		// Clean up resources and configure Texture.

		if ( isObjectURL === true ) {

			URL.revokeObjectURL( sourceURI );

		}

		texture.flipY = false;

		if ( textureDef.name !== undefined ) texture.name = textureDef.name;

		// Ignore unknown mime types, like DDS files.
		if ( source.mimeType in MIME_TYPE_FORMATS ) {

			texture.format = MIME_TYPE_FORMATS[ source.mimeType ];

		}

		var samplers = json.samplers || {};
		var sampler = samplers[ textureDef.sampler ] || {};

		texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;
		texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipmapLinearFilter;
		texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;
		texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;

		return texture;

	} );

};

/**
 * Asynchronously assigns a texture to the given material parameters.
 * @param {Object} materialParams
 * @param {string} mapName
 * @param {Object} mapDef
 * @return {Promise}
 */
GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {

	var parser = this;

	return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

		if ( ! texture.isCompressedTexture ) {

			switch ( mapName ) {

				case 'aoMap':
				case 'emissiveMap':
				case 'metalnessMap':
				case 'normalMap':
				case 'roughnessMap':
					texture.format = THREE.RGBFormat;
					break;

			}

		}

		if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

			var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

			if ( transform ) {

				texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );

			}

		}

		materialParams[ mapName ] = texture;

	} );

};

/**
 * Assigns final material to a Mesh, Line, or Points instance. The instance
 * already has a material (generated from the glTF material options alone)
 * but reuse of the same glTF material may require multiple threejs materials
 * to accomodate different primitive types, defines, etc. New materials will
 * be created if necessary, and reused from a cache.
 * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.
 */
GLTFParser.prototype.assignFinalMaterial = function ( mesh ) {

	var geometry = mesh.geometry;
	var material = mesh.material;
	var extensions = this.extensions;

	var useVertexTangents = geometry.attributes.tangent !== undefined;
	var useVertexColors = geometry.attributes.color !== undefined;
	var useFlatShading = geometry.attributes.normal === undefined;
	var useSkinning = mesh.isSkinnedMesh === true;
	var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
	var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

	if ( mesh.isPoints ) {

		var cacheKey = 'PointsMaterial:' + material.uuid;

		var pointsMaterial = this.cache.get( cacheKey );

		if ( ! pointsMaterial ) {

			pointsMaterial = new THREE.PointsMaterial();
			THREE.Material.prototype.copy.call( pointsMaterial, material );
			pointsMaterial.color.copy( material.color );
			pointsMaterial.map = material.map;
			pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

			this.cache.add( cacheKey, pointsMaterial );

		}

		material = pointsMaterial;

	} else if ( mesh.isLine ) {

		var cacheKey = 'LineBasicMaterial:' + material.uuid;

		var lineMaterial = this.cache.get( cacheKey );

		if ( ! lineMaterial ) {

			lineMaterial = new THREE.LineBasicMaterial();
			THREE.Material.prototype.copy.call( lineMaterial, material );
			lineMaterial.color.copy( material.color );

			this.cache.add( cacheKey, lineMaterial );

		}

		material = lineMaterial;

	}

	// Clone the material if it will be modified
	if ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {

		var cacheKey = 'ClonedMaterial:' + material.uuid + ':';

		if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
		if ( useSkinning ) cacheKey += 'skinning:';
		if ( useVertexTangents ) cacheKey += 'vertex-tangents:';
		if ( useVertexColors ) cacheKey += 'vertex-colors:';
		if ( useFlatShading ) cacheKey += 'flat-shading:';
		if ( useMorphTargets ) cacheKey += 'morph-targets:';
		if ( useMorphNormals ) cacheKey += 'morph-normals:';

		var cachedMaterial = this.cache.get( cacheKey );

		if ( ! cachedMaterial ) {

			cachedMaterial = material.isGLTFSpecularGlossinessMaterial
				? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material )
				: material.clone();

			if ( useSkinning ) cachedMaterial.skinning = true;
			if ( useVertexTangents ) cachedMaterial.vertexTangents = true;
			if ( useVertexColors ) cachedMaterial.vertexColors = THREE.VertexColors;
			if ( useFlatShading ) cachedMaterial.flatShading = true;
			if ( useMorphTargets ) cachedMaterial.morphTargets = true;
			if ( useMorphNormals ) cachedMaterial.morphNormals = true;

			this.cache.add( cacheKey, cachedMaterial );

		}

		material = cachedMaterial;

	}

	// workarounds for mesh and geometry

	if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

		console.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' );
		geometry.addAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );

	}

	if ( material.isGLTFSpecularGlossinessMaterial ) {

		// for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
		mesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;

	}

	mesh.material = material;

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
 * @param {number} materialIndex
 * @return {Promise<THREE.Material>}
 */
GLTFParser.prototype.loadMaterial = function ( materialIndex ) {

	var parser = this;
	var json = this.json;
	var extensions = this.extensions;
	var materialDef = json.materials[ materialIndex ];

	var materialType;
	var materialParams = {};
	var materialExtensions = materialDef.extensions || {};

	var pending = [];

	if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

		var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
		materialType = sgExtension.getMaterialType();
		pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

	} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

		var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
		materialType = kmuExtension.getMaterialType();
		pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

	} else {

		// Specification:
		// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

		materialType = THREE.MeshStandardMaterial;

		var metallicRoughness = materialDef.pbrMetallicRoughness || {};

		materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

			var array = metallicRoughness.baseColorFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( metallicRoughness.baseColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

		}

		materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
		materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

		if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
			pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

		}

	}

	if ( materialDef.doubleSided === true ) {

		materialParams.side = THREE.DoubleSide;

	}

	var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

	if ( alphaMode === ALPHA_MODES.BLEND ) {

		materialParams.transparent = true;

	} else {

		materialParams.transparent = false;

		if ( alphaMode === ALPHA_MODES.MASK ) {

			materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

		}

	}

	if ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

		pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

		materialParams.normalScale = new THREE.Vector2( 1, 1 );

		if ( materialDef.normalTexture.scale !== undefined ) {

			materialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );

		}

	}

	if ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

		pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

		if ( materialDef.occlusionTexture.strength !== undefined ) {

			materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

		}

	}

	if ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {

		materialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );

	}

	if ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

		pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

	}

	return Promise.all( pending ).then( function () {

		var material;

		if ( materialType === THREE.ShaderMaterial ) {

			material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

		} else {

			material = new materialType( materialParams );

		}

		if ( materialDef.name !== undefined ) material.name = materialDef.name;

		// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
		if ( material.map ) material.map.encoding = THREE.sRGBEncoding;
		if ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;
		if ( material.specularMap ) material.specularMap.encoding = THREE.sRGBEncoding;

		assignExtrasToUserData( material, materialDef );

		if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

		return material;

	} );

};

/**
 * @param {THREE.BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	var attributes = primitiveDef.attributes;

	var box = new THREE.Box3();

	if ( attributes.POSITION !== undefined ) {

		var accessor = parser.json.accessors[ attributes.POSITION ];
		var min = accessor.min;
		var max = accessor.max;

		box.set(
			new THREE.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
			new THREE.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );

	} else {

		return;

	}

	var targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		var vector = new THREE.Vector3();

		for ( var i = 0, il = targets.length; i < il; i ++ ) {

			var target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				var accessor = parser.json.accessors[ target.POSITION ];
				var min = accessor.min;
				var max = accessor.max;

				// we need to get max of absolute components because target weight is [-1,1]
				vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
				vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
				vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );

				box.expandByVector( vector );

			}

		}

	}

	geometry.boundingBox = box;

	var sphere = new THREE.Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {THREE.BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<THREE.BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	var attributes = primitiveDef.attributes;

	var pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.addAttribute( attributeName, accessor );

			} );

	}

	for ( var gltfAttributeName in attributes ) {

		var threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
 *
 * Creates BufferGeometries from primitives.
 *
 * @param {Array<GLTF.Primitive>} primitives
 * @return {Promise<Array<THREE.BufferGeometry>>}
 */
GLTFParser.prototype.loadGeometries = function ( primitives ) {

	var parser = this;
	var extensions = this.extensions;
	var cache = this.primitiveCache;

	function createDracoPrimitive( primitive ) {

		return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
			.decodePrimitive( primitive, parser )
			.then( function ( geometry ) {

				return addPrimitiveAttributes( geometry, primitive, parser );

			} );

	}

	var pending = [];

	for ( var i = 0, il = primitives.length; i < il; i ++ ) {

		var primitive = primitives[ i ];
		var cacheKey = createPrimitiveKey( primitive );

		// See if we've already created this geometry
		var cached = cache[ cacheKey ];

		if ( cached ) {

			// Use the cached geometry if it exists
			pending.push( cached.promise );

		} else {

			var geometryPromise;

			if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

				// Use DRACO geometry if available
				geometryPromise = createDracoPrimitive( primitive );

			} else {

				// Otherwise create a new geometry
				geometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );

			}

			// Cache this geometry
			cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

			pending.push( geometryPromise );

		}

	}

	return Promise.all( pending );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
 * @param {number} meshIndex
 * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}
 */
GLTFParser.prototype.loadMesh = function ( meshIndex ) {

	var parser = this;
	var json = this.json;

	var meshDef = json.meshes[ meshIndex ];
	var primitives = meshDef.primitives;

	var pending = [];

	for ( var i = 0, il = primitives.length; i < il; i ++ ) {

		var material = primitives[ i ].material === undefined
			? createDefaultMaterial()
			: this.getDependency( 'material', primitives[ i ].material );

		pending.push( material );

	}

	return Promise.all( pending ).then( function ( originalMaterials ) {

		return parser.loadGeometries( primitives ).then( function ( geometries ) {

			var meshes = [];

			for ( var i = 0, il = geometries.length; i < il; i ++ ) {

				var geometry = geometries[ i ];
				var primitive = primitives[ i ];

				// 1. create Mesh

				var mesh;

				var material = originalMaterials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
					primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
					primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
					primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See .markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new THREE.SkinnedMesh( geometry, material )
						: new THREE.Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.drawMode = THREE.TriangleStripDrawMode;

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.drawMode = THREE.TriangleFanDrawMode;

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new THREE.LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new THREE.Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new THREE.LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new THREE.Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = meshDef.name || ( 'mesh_' + meshIndex );

				if ( geometries.length > 1 ) mesh.name += '_' + i;

				assignExtrasToUserData( mesh, meshDef );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			var group = new THREE.Group();

			for ( var i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
 * @param {number} cameraIndex
 * @return {Promise<THREE.Camera>}
 */
GLTFParser.prototype.loadCamera = function ( cameraIndex ) {

	var camera;
	var cameraDef = this.json.cameras[ cameraIndex ];
	var params = cameraDef[ cameraDef.type ];

	if ( ! params ) {

		console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
		return;

	}

	if ( cameraDef.type === 'perspective' ) {

		camera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

	} else if ( cameraDef.type === 'orthographic' ) {

		camera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );

	}

	if ( cameraDef.name !== undefined ) camera.name = cameraDef.name;

	assignExtrasToUserData( camera, cameraDef );

	return Promise.resolve( camera );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
 * @param {number} skinIndex
 * @return {Promise<Object>}
 */
GLTFParser.prototype.loadSkin = function ( skinIndex ) {

	var skinDef = this.json.skins[ skinIndex ];

	var skinEntry = { joints: skinDef.joints };

	if ( skinDef.inverseBindMatrices === undefined ) {

		return Promise.resolve( skinEntry );

	}

	return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

		skinEntry.inverseBindMatrices = accessor;

		return skinEntry;

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
 * @param {number} animationIndex
 * @return {Promise<THREE.AnimationClip>}
 */
GLTFParser.prototype.loadAnimation = function ( animationIndex ) {

	var json = this.json;

	var animationDef = json.animations[ animationIndex ];

	var pendingNodes = [];
	var pendingInputAccessors = [];
	var pendingOutputAccessors = [];
	var pendingSamplers = [];
	var pendingTargets = [];

	for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {

		var channel = animationDef.channels[ i ];
		var sampler = animationDef.samplers[ channel.sampler ];
		var target = channel.target;
		var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
		var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
		var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

		pendingNodes.push( this.getDependency( 'node', name ) );
		pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
		pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
		pendingSamplers.push( sampler );
		pendingTargets.push( target );

	}

	return Promise.all( [

		Promise.all( pendingNodes ),
		Promise.all( pendingInputAccessors ),
		Promise.all( pendingOutputAccessors ),
		Promise.all( pendingSamplers ),
		Promise.all( pendingTargets )

	] ).then( function ( dependencies ) {

		var nodes = dependencies[ 0 ];
		var inputAccessors = dependencies[ 1 ];
		var outputAccessors = dependencies[ 2 ];
		var samplers = dependencies[ 3 ];
		var targets = dependencies[ 4 ];

		var tracks = [];

		for ( var i = 0, il = nodes.length; i < il; i ++ ) {

			var node = nodes[ i ];
			var inputAccessor = inputAccessors[ i ];
			var outputAccessor = outputAccessors[ i ];
			var sampler = samplers[ i ];
			var target = targets[ i ];

			if ( node === undefined ) continue;

			node.updateMatrix();
			node.matrixAutoUpdate = true;

			var TypedKeyframeTrack;

			switch ( PATH_PROPERTIES[ target.path ] ) {

				case PATH_PROPERTIES.weights:

					TypedKeyframeTrack = THREE.NumberKeyframeTrack;
					break;

				case PATH_PROPERTIES.rotation:

					TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
					break;

				case PATH_PROPERTIES.position:
				case PATH_PROPERTIES.scale:
				default:

					TypedKeyframeTrack = THREE.VectorKeyframeTrack;
					break;

			}

			var targetName = node.name ? node.name : node.uuid;

			var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;

			var targetNames = [];

			if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

				// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.
				node.traverse( function ( object ) {

					if ( object.isMesh === true && object.morphTargetInfluences ) {

						targetNames.push( object.name ? object.name : object.uuid );

					}

				} );

			} else {

				targetNames.push( targetName );

			}

			var outputArray = outputAccessor.array;

			if ( outputAccessor.normalized ) {

				var scale;

				if ( outputArray.constructor === Int8Array ) {

					scale = 1 / 127;

				} else if ( outputArray.constructor === Uint8Array ) {

					scale = 1 / 255;

				} else if ( outputArray.constructor == Int16Array ) {

					scale = 1 / 32767;

				} else if ( outputArray.constructor === Uint16Array ) {

					scale = 1 / 65535;

				} else {

					throw new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );

				}

				var scaled = new Float32Array( outputArray.length );

				for ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {

					scaled[ j ] = outputArray[ j ] * scale;

				}

				outputArray = scaled;

			}

			for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {

				var track = new TypedKeyframeTrack(
					targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
					inputAccessor.array,
					outputArray,
					interpolation
				);

				// Override interpolation with custom factory method.
				if ( sampler.interpolation === 'CUBICSPLINE' ) {

					track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

						// A CUBICSPLINE keyframe in glTF has three output values for each input value,
						// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
						// must be divided by three to get the interpolant's sampleSize argument.

						return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

					};

					// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
					track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

				}

				tracks.push( track );

			}

		}

		var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;

		return new THREE.AnimationClip( name, undefined, tracks );

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
 * @param {number} nodeIndex
 * @return {Promise<THREE.Object3D>}
 */
GLTFParser.prototype.loadNode = function ( nodeIndex ) {

	var json = this.json;
	var extensions = this.extensions;
	var parser = this;

	var meshReferences = json.meshReferences;
	var meshUses = json.meshUses;

	var nodeDef = json.nodes[ nodeIndex ];

	return ( function () {

		var pending = [];

		if ( nodeDef.mesh !== undefined ) {

			pending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

				var node;

				if ( meshReferences[ nodeDef.mesh ] > 1 ) {

					var instanceNum = meshUses[ nodeDef.mesh ] ++;

					node = mesh.clone();
					node.name += '_instance_' + instanceNum;

					// onBeforeRender copy for Specular-Glossiness
					node.onBeforeRender = mesh.onBeforeRender;

					for ( var i = 0, il = node.children.length; i < il; i ++ ) {

						node.children[ i ].name += '_instance_' + instanceNum;
						node.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender;

					}

				} else {

					node = mesh;

				}

				// if weights are provided on the node, override weights on the mesh.
				if ( nodeDef.weights !== undefined ) {

					node.traverse( function ( o ) {

						if ( ! o.isMesh ) return;

						for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

							o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

						}

					} );

				}

				return node;

			} ) );

		}

		if ( nodeDef.camera !== undefined ) {

			pending.push( parser.getDependency( 'camera', nodeDef.camera ) );

		}

		if ( nodeDef.extensions
			&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]
			&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {

			pending.push( parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ) );

		}

		return Promise.all( pending );

	}() ).then( function ( objects ) {

		var node;

		// .isBone isn't in glTF spec. See .markDefs
		if ( nodeDef.isBone === true ) {

			node = new THREE.Bone();

		} else if ( objects.length > 1 ) {

			node = new THREE.Group();

		} else if ( objects.length === 1 ) {

			node = objects[ 0 ];

		} else {

			node = new THREE.Object3D();

		}

		if ( node !== objects[ 0 ] ) {

			for ( var i = 0, il = objects.length; i < il; i ++ ) {

				node.add( objects[ i ] );

			}

		}

		if ( nodeDef.name !== undefined ) {

			node.userData.name = nodeDef.name;
			node.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );

		}

		assignExtrasToUserData( node, nodeDef );

		if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

		if ( nodeDef.matrix !== undefined ) {

			var matrix = new THREE.Matrix4();
			matrix.fromArray( nodeDef.matrix );
			node.applyMatrix( matrix );

		} else {

			if ( nodeDef.translation !== undefined ) {

				node.position.fromArray( nodeDef.translation );

			}

			if ( nodeDef.rotation !== undefined ) {

				node.quaternion.fromArray( nodeDef.rotation );

			}

			if ( nodeDef.scale !== undefined ) {

				node.scale.fromArray( nodeDef.scale );

			}

		}

		return node;

	} );

};

/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
 * @param {number} sceneIndex
 * @return {Promise<THREE.Scene>}
 */
GLTFParser.prototype.loadScene = function () {

	// scene node hierachy builder

	function buildNodeHierachy( nodeId, parentObject, json, parser ) {

		var nodeDef = json.nodes[ nodeId ];

		return parser.getDependency( 'node', nodeId ).then( function ( node ) {

			if ( nodeDef.skin === undefined ) return node;

			// build skeleton here as well

			var skinEntry;

			return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

				skinEntry = skin;

				var pendingJoints = [];

				for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

					pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

				}

				return Promise.all( pendingJoints );

			} ).then( function ( jointNodes ) {

				node.traverse( function ( mesh ) {

					if ( ! mesh.isMesh ) return;

					var bones = [];
					var boneInverses = [];

					for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {

						var jointNode = jointNodes[ j ];

						if ( jointNode ) {

							bones.push( jointNode );

							var mat = new THREE.Matrix4();

							if ( skinEntry.inverseBindMatrices !== undefined ) {

								mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

							}

							boneInverses.push( mat );

						} else {

							console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

						}

					}

					mesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );

				} );

				return node;

			} );

		} ).then( function ( node ) {

			// build node hierachy

			parentObject.add( node );

			var pending = [];

			if ( nodeDef.children ) {

				var children = nodeDef.children;

				for ( var i = 0, il = children.length; i < il; i ++ ) {

					var child = children[ i ];
					pending.push( buildNodeHierachy( child, node, json, parser ) );

				}

			}

			return Promise.all( pending );

		} );

	}

	return function loadScene( sceneIndex ) {

		var json = this.json;
		var extensions = this.extensions;
		var sceneDef = this.json.scenes[ sceneIndex ];
		var parser = this;

		var scene = new THREE.Scene();
		if ( sceneDef.name !== undefined ) scene.name = sceneDef.name;

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		var nodeIds = sceneDef.nodes || [];

		var pending = [];

		for ( var i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			return scene;

		} );

	};

}();

return GLTFLoader;

} )();


// module.exports = _GLTFLoader;








( function () {

function computeTangents( geometry ) {

	geometry.computeTangents();
	console.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use THREE.BufferGeometry.computeTangents() instead.' );

}
/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */


function mergeBufferGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;
	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );
	const attributes = {};
	const morphAttributes = {};
	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;
	const mergedGeometry = new THREE.BufferGeometry();
	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0; // ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		} // gather attributes, exit early if they're different


		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];
			attributes[ name ].push( geometry.attributes[ name ] );
			attributesCount ++;

		} // ensure geometries have the same number of attributes


		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		} // gather morph attributes, exit early if they're different


		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];
			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		} // gather .userData


		mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
		mergedGeometry.userData.mergedUserData.push( geometry.userData );

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );
			offset += count;

		}

	} // merge indices


	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	} // merge attributes


	for ( const name in attributes ) {

		const mergedAttribute = mergeBufferAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.addAttribute( name, mergedAttribute );

	} // merge morph attributes


	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;
		if ( numMorphTargets === 0 ) break;
		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}
/**
* @param {Array<BufferAttribute>} attributes
* @return {BufferAttribute}
*/


function mergeBufferAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;

		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;

		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;

		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );
		offset += attributes[ i ].array.length;

	}

	return new THREE.BufferAttribute( array, itemSize, normalized );

}
/**
* @param {Array<BufferAttribute>} attributes
* @return {Array<InterleavedBufferAttribute>}
*/


function interleaveAttributes( attributes ) {

	// Interleaves the provided attributes into an THREE.InterleavedBuffer and returns
	// a set of InterleavedBufferAttributes for each attribute
	let TypedArray;
	let arrayLength = 0;
	let stride = 0; // calculate the the length and type of the interleavedBuffer

	for ( let i = 0, l = attributes.length; i < l; ++ i ) {

		const attribute = attributes[ i ];
		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;

		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'AttributeBuffers of different types cannot be interleaved' );
			return null;

		}

		arrayLength += attribute.array.length;
		stride += attribute.itemSize;

	} // Create the set of buffer attributes


	const interleavedBuffer = new THREE.InterleavedBuffer( new TypedArray( arrayLength ), stride );
	let offset = 0;
	const res = [];
	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

	for ( let j = 0, l = attributes.length; j < l; j ++ ) {

		const attribute = attributes[ j ];
		const itemSize = attribute.itemSize;
		const count = attribute.count;
		const iba = new THREE.InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );
		res.push( iba );
		offset += itemSize; // Move the data for each attribute into the new interleavedBuffer
		// at the appropriate offset

		for ( let c = 0; c < count; c ++ ) {

			for ( let k = 0; k < itemSize; k ++ ) {

				iba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );

			}

		}

	}

	return res;

}
/**
* @param {Array<BufferGeometry>} geometry
* @return {number}
*/


function estimateBytesUsed( geometry ) {

	// Return the estimated memory used by this geometry in bytes
	// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
	// for InterleavedBufferAttributes.
	let mem = 0;

	for ( const name in geometry.attributes ) {

		const attr = geometry.getAttribute( name );
		mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;

	}

	const indices = geometry.getIndex();
	mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
	return mem;

}
/**
* @param {BufferGeometry} geometry
* @param {number} tolerance
* @return {BufferGeometry>}
*/


function mergeVertices( geometry, tolerance = 1e-4 ) {

	tolerance = Math.max( tolerance, Number.EPSILON ); // Generate an index buffer if the geometry doesn't have one, or optimize it
	// if it's already available.

	const hashToIndex = {};
	const indices = geometry.getIndex();
	const positions = geometry.getAttribute( 'position' );
	const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices

	let nextIndex = 0; // attributes and new attribute arrays

	const attributeNames = Object.keys( geometry.attributes );
	const attrArrays = {};
	const morphAttrsArrays = {};
	const newIndices = [];
	const getters = [ 'getX', 'getY', 'getZ', 'getW' ]; // initialize the arrays

	for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {

		const name = attributeNames[ i ];
		attrArrays[ name ] = [];
		const morphAttr = geometry.morphAttributes[ name ];

		if ( morphAttr ) {

			morphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );

		}

	} // convert the error tolerance to an amount of decimal places to truncate to


	const decimalShift = Math.log10( 1 / tolerance );
	const shiftMultiplier = Math.pow( 10, decimalShift );

	for ( let i = 0; i < vertexCount; i ++ ) {

		const index = indices ? indices.getX( i ) : i; // Generate a hash for the vertex attributes at the current index 'i'

		let hash = '';

		for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

			const name = attributeNames[ j ];
			const attribute = geometry.getAttribute( name );
			const itemSize = attribute.itemSize;

			for ( let k = 0; k < itemSize; k ++ ) {

				// double tilde truncates the decimal value
				hash += `${~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier )},`;

			}

		} // Add another reference to the vertex if it's already
		// used by another index


		if ( hash in hashToIndex ) {

			newIndices.push( hashToIndex[ hash ] );

		} else {

			// copy data to the new index in the attribute arrays
			for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

				const name = attributeNames[ j ];
				const attribute = geometry.getAttribute( name );
				const morphAttr = geometry.morphAttributes[ name ];
				const itemSize = attribute.itemSize;
				const newarray = attrArrays[ name ];
				const newMorphArrays = morphAttrsArrays[ name ];

				for ( let k = 0; k < itemSize; k ++ ) {

					const getterFunc = getters[ k ];
					newarray.push( attribute[ getterFunc ]( index ) );

					if ( morphAttr ) {

						for ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {

							newMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );

						}

					}

				}

			}

			hashToIndex[ hash ] = nextIndex;
			newIndices.push( nextIndex );
			nextIndex ++;

		}

	} // Generate typed arrays from new attribute arrays and update
	// the attributeBuffers


	const result = geometry.clone();

	for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {

		const name = attributeNames[ i ];
		const oldAttribute = geometry.getAttribute( name );
		const buffer = new oldAttribute.array.constructor( attrArrays[ name ] );
		const attribute = new THREE.BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );
		result.addAttribute( name, attribute ); // Update the attribute arrays

		if ( name in morphAttrsArrays ) {

			for ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {

				const oldMorphAttribute = geometry.morphAttributes[ name ][ j ];
				const buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );
				const morphAttribute = new THREE.BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );
				result.morphAttributes[ name ][ j ] = morphAttribute;

			}

		}

	} // indices


	result.setIndex( newIndices );
	return result;

}
/**
* @param {BufferGeometry} geometry
* @param {number} drawMode
* @return {BufferGeometry>}
*/


function toTrianglesDrawMode( geometry, drawMode ) {

	if ( drawMode === THREE.TrianglesDrawMode ) {

		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
		return geometry;

	}

	if ( drawMode === THREE.TriangleFanDrawMode || drawMode === THREE.TriangleStripDrawMode ) {

		let index = geometry.getIndex(); // generate index if not present

		if ( index === null ) {

			const indices = [];
			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		} //


		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === THREE.TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN
			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP
			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( newIndices.length / 3 !== numberOfTriangles ) {

			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		} // build final geometry


		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		newGeometry.clearGroups();
		return newGeometry;

	} else {

		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
		return geometry;

	}

}
/**
* Calculates the morphed attributes of a morphed/skinned THREE.BufferGeometry.
* Helpful for Raytracing or Decals.
* @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
* @return {Object} An Object with original position/normal attributes and morphed ones.
*/


function computeMorphedAttributes( object ) {

	if ( object.geometry.isBufferGeometry !== true ) {

		console.error( 'THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry.' );
		return null;

	}

	const _vA = new THREE.Vector3();

	const _vB = new THREE.Vector3();

	const _vC = new THREE.Vector3();

	const _tempA = new THREE.Vector3();

	const _tempB = new THREE.Vector3();

	const _tempC = new THREE.Vector3();

	const _morphA = new THREE.Vector3();

	const _morphB = new THREE.Vector3();

	const _morphC = new THREE.Vector3();

	function _calculateMorphedAttributeData( object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray ) {

		_vA.fromBufferAttribute( attribute, a );

		_vB.fromBufferAttribute( attribute, b );

		_vC.fromBufferAttribute( attribute, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( material.morphTargets && morphAttribute && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			_morphB.set( 0, 0, 0 );

			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morph = morphAttribute[ i ];
				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morph, a );

				_tempB.fromBufferAttribute( morph, b );

				_tempC.fromBufferAttribute( morph, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

					_morphB.addScaledVector( _tempB, influence );

					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA ), influence );

					_morphB.addScaledVector( _tempB.sub( _vB ), influence );

					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

				}

			}

			_vA.add( _morphA );

			_vB.add( _morphB );

			_vC.add( _morphC );

		}

		if ( object.isSkinnedMesh ) {

			object.boneTransform( a, _vA );
			object.boneTransform( b, _vB );
			object.boneTransform( c, _vC );

		}

		modifiedAttributeArray[ a * 3 + 0 ] = _vA.x;
		modifiedAttributeArray[ a * 3 + 1 ] = _vA.y;
		modifiedAttributeArray[ a * 3 + 2 ] = _vA.z;
		modifiedAttributeArray[ b * 3 + 0 ] = _vB.x;
		modifiedAttributeArray[ b * 3 + 1 ] = _vB.y;
		modifiedAttributeArray[ b * 3 + 2 ] = _vB.z;
		modifiedAttributeArray[ c * 3 + 0 ] = _vC.x;
		modifiedAttributeArray[ c * 3 + 1 ] = _vC.y;
		modifiedAttributeArray[ c * 3 + 2 ] = _vC.z;

	}

	const geometry = object.geometry;
	const material = object.material;
	let a, b, c;
	const index = geometry.index;
	const positionAttribute = geometry.attributes.position;
	const morphPosition = geometry.morphAttributes.position;
	const morphTargetsRelative = geometry.morphTargetsRelative;
	const normalAttribute = geometry.attributes.normal;
	const morphNormal = geometry.morphAttributes.position;
	const groups = geometry.groups;
	const drawRange = geometry.drawRange;
	let i, j, il, jl;
	let group, groupMaterial;
	let start, end;
	const modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );
	const modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );

	if ( index !== null ) {

		// indexed buffer geometry
		if ( Array.isArray( material ) ) {

			for ( i = 0, il = groups.length; i < il; i ++ ) {

				group = groups[ i ];
				groupMaterial = material[ group.materialIndex ];
				start = Math.max( group.start, drawRange.start );
				end = Math.min( group.start + group.count, drawRange.start + drawRange.count );

				for ( j = start, jl = end; j < jl; j += 3 ) {

					a = index.getX( j );
					b = index.getX( j + 1 );
					c = index.getX( j + 2 );

					_calculateMorphedAttributeData( object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition );

					_calculateMorphedAttributeData( object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal );

				}

			}

		} else {

			start = Math.max( 0, drawRange.start );
			end = Math.min( index.count, drawRange.start + drawRange.count );

			for ( i = start, il = end; i < il; i += 3 ) {

				a = index.getX( i );
				b = index.getX( i + 1 );
				c = index.getX( i + 2 );

				_calculateMorphedAttributeData( object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition );

				_calculateMorphedAttributeData( object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal );

			}

		}

	} else {

		// non-indexed buffer geometry
		if ( Array.isArray( material ) ) {

			for ( i = 0, il = groups.length; i < il; i ++ ) {

				group = groups[ i ];
				groupMaterial = material[ group.materialIndex ];
				start = Math.max( group.start, drawRange.start );
				end = Math.min( group.start + group.count, drawRange.start + drawRange.count );

				for ( j = start, jl = end; j < jl; j += 3 ) {

					a = j;
					b = j + 1;
					c = j + 2;

					_calculateMorphedAttributeData( object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition );

					_calculateMorphedAttributeData( object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal );

				}

			}

		} else {

			start = Math.max( 0, drawRange.start );
			end = Math.min( positionAttribute.count, drawRange.start + drawRange.count );

			for ( i = start, il = end; i < il; i += 3 ) {

				a = i;
				b = i + 1;
				c = i + 2;

				_calculateMorphedAttributeData( object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition );

				_calculateMorphedAttributeData( object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal );

			}

		}

	}

	const morphedPositionAttribute = new THREE.Float32BufferAttribute( modifiedPosition, 3 );
	const morphedNormalAttribute = new THREE.Float32BufferAttribute( modifiedNormal, 3 );
	return {
		positionAttribute: positionAttribute,
		normalAttribute: normalAttribute,
		morphedPositionAttribute: morphedPositionAttribute,
		morphedNormalAttribute: morphedNormalAttribute
	};

}

THREE.BufferGeometryUtils = {};
THREE.BufferGeometryUtils.computeMorphedAttributes = computeMorphedAttributes;
THREE.BufferGeometryUtils.computeTangents = computeTangents;
THREE.BufferGeometryUtils.estimateBytesUsed = estimateBytesUsed;
THREE.BufferGeometryUtils.interleaveAttributes = interleaveAttributes;
THREE.BufferGeometryUtils.mergeBufferAttributes = mergeBufferAttributes;
THREE.BufferGeometryUtils.mergeBufferGeometries = mergeBufferGeometries;
THREE.BufferGeometryUtils.mergeVertices = mergeVertices;
THREE.BufferGeometryUtils.toTrianglesDrawMode = toTrianglesDrawMode;

} )();



//OBJLoader

( function () {

const _object_pattern = /^[og]\s*(.+)?/; // mtllib file_reference

const _material_library_pattern = /^mtllib /; // usemtl material_name

const _material_use_pattern = /^usemtl /; // usemap map_name

const _map_use_pattern = /^usemap /;

const _vA = new THREE.Vector3();

const _vB = new THREE.Vector3();

const _vC = new THREE.Vector3();

const _ab = new THREE.Vector3();

const _cb = new THREE.Vector3();

const _color = new THREE.Color();

function ParserState() {

	const state = {
		objects: [],
		object: {},
		vertices: [],
		normals: [],
		colors: [],
		uvs: [],
		materials: {},
		materialLibraries: [],
		startObject: function ( name, fromDeclaration ) {

			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {

				this.object.name = name;
				this.object.fromDeclaration = fromDeclaration !== false;
				return;

			}

			const previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

			this.object = {
				name: name || '',
				fromDeclaration: fromDeclaration !== false,
				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,
				startMaterial: function ( name, libraries ) {

					const previous = this._finalize( false ); // New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.


					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

						this.materials.splice( previous.index, 1 );

					}

					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '',
						smooth: previous !== undefined ? previous.smooth : this.smooth,
						groupStart: previous !== undefined ? previous.groupEnd : 0,
						groupEnd: - 1,
						groupCount: - 1,
						inherited: false,
						clone: function ( index ) {

							const cloned = {
								index: typeof index === 'number' ? index : this.index,
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: - 1,
								groupCount: - 1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;

						}
					};
					this.materials.push( material );
					return material;

				},
				currentMaterial: function () {

					if ( this.materials.length > 0 ) {

						return this.materials[ this.materials.length - 1 ];

					}

					return undefined;

				},
				_finalize: function ( end ) {

					const lastMultiMaterial = this.currentMaterial();

					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {

						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;

					} // Ignore objects tail materials if no face declarations followed them before a new o/g started.


					if ( end && this.materials.length > 1 ) {

						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {

							if ( this.materials[ mi ].groupCount <= 0 ) {

								this.materials.splice( mi, 1 );

							}

						}

					} // Guarantee at least one empty material, this makes the creation later more straight forward.


					if ( end && this.materials.length === 0 ) {

						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );

					}

					return lastMultiMaterial;

				}
			}; // Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );

			}

			this.objects.push( this.object );

		},
		finalize: function () {

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

		},
		parseVertexIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},
		parseNormalIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},
		parseUVIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

		},
		addVertex: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},
		addVertexPoint: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},
		addVertexLine: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},
		addNormal: function ( a, b, c ) {

			const src = this.normals;
			const dst = this.object.geometry.normals;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},
		addFaceNormal: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.normals;

			_vA.fromArray( src, a );

			_vB.fromArray( src, b );

			_vC.fromArray( src, c );

			_cb.subVectors( _vC, _vB );

			_ab.subVectors( _vA, _vB );

			_cb.cross( _ab );

			_cb.normalize();

			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );

		},
		addColor: function ( a, b, c ) {

			const src = this.colors;
			const dst = this.object.geometry.colors;
			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},
		addUV: function ( a, b, c ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;
			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );

		},
		addDefaultUV: function () {

			const dst = this.object.geometry.uvs;
			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );

		},
		addUVLine: function ( a ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;
			dst.push( src[ a + 0 ], src[ a + 1 ] );

		},
		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

			const vLen = this.vertices.length;
			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );
			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic ); // normals

			if ( na !== undefined && na !== '' ) {

				const nLen = this.normals.length;
				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );
				this.addNormal( ia, ib, ic );

			} else {

				this.addFaceNormal( ia, ib, ic );

			} // uvs


			if ( ua !== undefined && ua !== '' ) {

				const uvLen = this.uvs.length;
				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );
				this.addUV( ia, ib, ic );
				this.object.geometry.hasUVIndices = true;

			} else {

				// add placeholder values (for inconsistent face definitions)
				this.addDefaultUV();

			}

		},
		addPointGeometry: function ( vertices ) {

			this.object.geometry.type = 'Points';
			const vLen = this.vertices.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				const index = this.parseVertexIndex( vertices[ vi ], vLen );
				this.addVertexPoint( index );
				this.addColor( index );

			}

		},
		addLineGeometry: function ( vertices, uvs ) {

			this.object.geometry.type = 'Line';
			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

			}

			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

			}

		}
	};
	state.startObject( '', false );
	return state;

} //


class OBJLoader extends THREE.Loader {

	constructor( manager ) {

		super( manager );
		this.materials = null;

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;
		const loader = new THREE.FileLoader( this.manager );
		loader.setPath( this.path );
		// loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterials( materials ) {

		this.materials = materials;
		return this;

	}

	parse( text ) {

		const state = new ParserState();

		if ( text.indexOf( '\r\n' ) !== - 1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== - 1 ) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		const lines = text.split( '\n' );
		let line = '',
			lineFirstChar = '';
		let lineLength = 0;
		let result = []; // Faster to just trim left side of the line. Use if available.

		const trimLeft = typeof ''.trimLeft === 'function';

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			line = lines[ i ];
			line = trimLeft ? line.trimLeft() : line.trim();
			lineLength = line.length;
			if ( lineLength === 0 ) continue;
			lineFirstChar = line.charAt( 0 ); // @todo invoke passed in handler if any

			if ( lineFirstChar === '#' ) continue;

			if ( lineFirstChar === 'v' ) {

				const data = line.split( /\s+/ );

				switch ( data[ 0 ] ) {

					case 'v':
						state.vertices.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) );

						if ( data.length >= 7 ) {

							_color.setRGB( parseFloat( data[ 4 ] ), parseFloat( data[ 5 ] ), parseFloat( data[ 6 ] ) ).convertSRGBToLinear();

							state.colors.push( _color.r, _color.g, _color.b );

						} else {

							// if no colors are defined, add placeholders so color and vertex indices match
							state.colors.push( undefined, undefined, undefined );

						}

						break;

					case 'vn':
						state.normals.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) );
						break;

					case 'vt':
						state.uvs.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );
						break;

				}

			} else if ( lineFirstChar === 'f' ) {

				const lineData = line.substr( 1 ).trim();
				const vertexData = lineData.split( /\s+/ );
				const faceVertices = []; // Parse the face vertex data into an easy to work with format

				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {

					const vertex = vertexData[ j ];

					if ( vertex.length > 0 ) {

						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );

					}

				} // Draw an edge between the first vertex and all subsequent vertices to form an n-gon


				const v1 = faceVertices[ 0 ];

				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];
					state.addFace( v1[ 0 ], v2[ 0 ], v3[ 0 ], v1[ 1 ], v2[ 1 ], v3[ 1 ], v1[ 2 ], v2[ 2 ], v3[ 2 ] );

				}

			} else if ( lineFirstChar === 'l' ) {

				const lineParts = line.substring( 1 ).trim().split( ' ' );
				let lineVertices = [];
				const lineUVs = [];

				if ( line.indexOf( '/' ) === - 1 ) {

					lineVertices = lineParts;

				} else {

					for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {

						const parts = lineParts[ li ].split( '/' );
						if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

					}

				}

				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( lineFirstChar === 'p' ) {

				const lineData = line.substr( 1 ).trim();
				const pointData = lineData.split( ' ' );
				state.addPointGeometry( pointData );

			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name
				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// let name = result[ 0 ].substr( 1 ).trim();
				const name = ( ' ' + result[ 0 ].substr( 1 ).trim() ).substr( 1 );
				state.startObject( name );

			} else if ( _material_use_pattern.test( line ) ) {

				// material
				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( _material_library_pattern.test( line ) ) {

				// mtl file
				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( _map_use_pattern.test( line ) ) {

				// the line is parsed but ignored since the loader assumes textures are defined MTL files
				// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)
				console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

			} else if ( lineFirstChar === 's' ) {

				result = line.split( ' ' ); // smooth shading
				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				/*
		 * http://paulbourke.net/dataformats/obj/
		 *
		 * From chapter "Grouping" Syntax explanation "s group_number":
		 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
		 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
		 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
		 * than 0."
		 */

				if ( result.length > 1 ) {

					const value = result[ 1 ].trim().toLowerCase();
					state.object.smooth = value !== '0' && value !== 'off';

				} else {

					// ZBrush can produce "s" lines #11707
					state.object.smooth = true;

				}

				const material = state.object.currentMaterial();
				if ( material ) material.smooth = state.object.smooth;

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;
				console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

			}

		}

		state.finalize();
		const container = new THREE.Group();
		container.materialLibraries = [].concat( state.materialLibraries );
		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

		if ( hasPrimitives === true ) {

			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {

				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = geometry.type === 'Line';
				const isPoints = geometry.type === 'Points';
				let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces

				if ( geometry.vertices.length === 0 ) continue;
				const BufferGeometry = new THREE.BufferGeometry();
				BufferGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( geometry.vertices, 3 ) );

				if ( geometry.normals.length > 0 ) {

					BufferGeometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( geometry.normals, 3 ) );

				}

				if ( geometry.colors.length > 0 ) {

					hasVertexColors = true;
					BufferGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );

				}

				if ( geometry.hasUVIndices === true ) {

					BufferGeometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( geometry.uvs, 2 ) );

				} // Create materials


				const createdMaterials = [];

				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name ); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.

						if ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {

							const materialLine = new THREE.LineBasicMaterial();
							THREE.Material.prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;

						} else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {

							const materialPoints = new THREE.PointsMaterial( {
								size: 10,
								sizeAttenuation: false
							} );
							THREE.Material.prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;

						}

					}

					if ( material === undefined ) {

						if ( isLine ) {

							material = new THREE.LineBasicMaterial();

						} else if ( isPoints ) {

							material = new THREE.PointsMaterial( {
								size: 1,
								sizeAttenuation: false
							} );

						} else {

							material = new THREE.MeshPhongMaterial();

						}

						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;
						state.materials[ materialHash ] = material;

					}

					createdMaterials.push( material );

				} // Create mesh


				let mesh;

				if ( createdMaterials.length > 1 ) {

					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						const sourceMaterial = materials[ mi ];
						BufferGeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					if ( isLine ) {

						mesh = new THREE.LineSegments( BufferGeometry, createdMaterials );

					} else if ( isPoints ) {

						mesh = new THREE.Points( BufferGeometry, createdMaterials );

					} else {

						mesh = new THREE.Mesh( BufferGeometry, createdMaterials );

					}

				} else {

					if ( isLine ) {

						mesh = new THREE.LineSegments( BufferGeometry, createdMaterials[ 0 ] );

					} else if ( isPoints ) {

						mesh = new THREE.Points( BufferGeometry, createdMaterials[ 0 ] );

					} else {

						mesh = new THREE.Mesh( BufferGeometry, createdMaterials[ 0 ] );

					}

				}

				mesh.name = object.name;
				container.add( mesh );

			}

		} else {

			// if there is only the default parser state object with no geometry data, interpret data as point cloud
			if ( state.vertices.length > 0 ) {

				const material = new THREE.PointsMaterial( {
					size: 1,
					sizeAttenuation: false
				} );
				const BufferGeometry = new THREE.BufferGeometry();
				BufferGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( state.vertices, 3 ) );

				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

					BufferGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( state.colors, 3 ) );
					material.vertexColors = true;

				}

				const points = new THREE.Points( BufferGeometry, material );
				container.add( points );

			}

		}

		return container;

	}

}

THREE.OBJLoader = OBJLoader;

} )();

//ABOVE ALL LOADER CODE FROM THREE JS, DO NOT EDIT



						
			var renderer = new THREE.WebGLRenderer({
				antialias	: true,
				alpha: true
			});
			renderer.setClearColor(new THREE.Color('lightgrey'), 0)
			// renderer.setPixelRatio( 2 );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.domElement.style.position = 'absolute'
			renderer.domElement.style.top = '0px'
			renderer.domElement.style.left = '0px'
			document.body.appendChild( renderer.domElement );

			// LIGHTS FOR GLTF MODEL
			const light = new THREE.DirectionalLight(0xffffff, 2)
			light.position.set(2, 2, 2)

		
			// init scene and camera
			var scene = new THREE.Scene();
			var camera = new THREE.Camera();
			scene.add(camera, light);

			var markerGroup = new THREE.Group();
			scene.add(markerGroup);
		
			var source = new THREEAR.Source({ renderer, camera });

			THREEAR.initialize({ source: source }).then((controller) => {

				// add a torus knot and cube		
				var geometry = new THREE.TorusKnotGeometry(0.3,0.1,64,16);
				var material = new THREE.MeshNormalMaterial(); 







// GLTF LOADER
{
    const planeSize = 0.1;

    const loader = new THREE.TextureLoader();
    // const texture = loader.load('https://threejs.org/manual/examples/resources/images/checker.png');
    // texture.wrapS = THREE.RepeatWrapping;
    // texture.wrapT = THREE.RepeatWrapping;
    // texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    // texture.repeat.set(repeats, repeats);

    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
    //   map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    scene.add(mesh);
  }


  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 0, 0);
    scene.add(light);
    scene.add(light.target);
  }
const gltfLoader = new GLTFLoader();
    gltfLoader.load('/data/coin_3.glb', (gltf) => {
      const root = gltf.scene;
      scene.add(root);
	  gltf.scene.scale.set(0.030, 0.030, 0.030);
	  gltf.scene.position.y = 0.5


	  var lastTimeMsec = 0;
				requestAnimationFrame(function animate(nowMsec){
					// keep looping
					requestAnimationFrame( animate );
					// measure time
					lastTimeMsec = lastTimeMsec || nowMsec-1000/60;
					var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
					lastTimeMsec = nowMsec;
					// call each update function
					controller.update( source.domElement );
					// cube.rotation.x += deltaMsec/10000 * Math.PI

					//BELOW TORUS KNOT CODE
					gltf.scene.rotation.y += deltaMsec/1500 * Math.PI
					gltf.scene.rotation.z += deltaMsec/1500 * Math.PI
	


					renderer.render( scene, camera );
					// controls.update();
				});
  
	  console.log('new:', gltf)

      // compute the box that contains all the stuff
      // from root and below
      const box = new THREE.Box3().setFromObject(root);

      const boxSize = box.getSize(new THREE.Vector3()).length();
      const boxCenter = box.getCenter(new THREE.Vector3());

	markerGroup.add(root);

    });
function animate() {
  requestAnimationFrame( animate );
  renderer.render( scene, camera );

}
animate()
renderer.render( scene, camera );








		// BELOW  ADD OBJ MODEL WORKS			
		// 		const newloader = new THREE.OBJLoader();

		// 		const teapot = "/data/teapot.obj"

		// 		newloader.load(teapot, function (object) {
		// 		scene.add(object);
		// 		console.log(object);
		// 		renderer.render(scene, camera);
		// 		object.position.y = 0.5
		// 		// object.position.x = 0.5
		// 		object.scale.setScalar(0.1);
		// 		function animate() {
					
		// 			requestAnimationFrame( animate );
		// 			if (teapot) {
		// 				teapot.position.x += 3;
		// 				console.log("teapot");
		// 				//etc
		// 			}
		// 		}
		// 		markerGroup.add(object);				
  		// });









				//BELOW TORUS KNOT CODE
				// var torus = new THREE.Mesh( geometry, material );
				// torus.position.y = 0.5
				// markerGroup.add(torus);
				// torus.scale.setScalar(0.5);

				//TUNRED OFF CUBE BELOW
				// var geometry = new THREE.CubeGeometry(1,1,1);
				// var material = new THREE.MeshNormalMaterial({
					// transparent : true,
					
					// opacity: 0,
					// side: THREE.DoubleSide
				// }); 
				// var cube = new THREE.Mesh( geometry, material );
				// cube.position.y	= geometry.parameters.height / 2;
				// markerGroup.add(cube)

				var patternMarker = new THREEAR.PatternMarker({
					patternUrl: '../data/patt.hiro',
					markerObject: markerGroup
				});

				controller.trackMarker(patternMarker);








				// run the rendering loop
				var lastTimeMsec = 0;
				requestAnimationFrame(function animate(nowMsec){
					// keep looping
					requestAnimationFrame( animate );
					// measure time
					lastTimeMsec = lastTimeMsec || nowMsec-1000/60;
					var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
					lastTimeMsec = nowMsec;
					// call each update function
					controller.update( source.domElement );
					// cube.rotation.x += deltaMsec/10000 * Math.PI

					//BELOW TORUS KNOT CODE
					// torus.rotation.y += deltaMsec/1000 * Math.PI
					// torus.rotation.z += deltaMsec/1000 * Math.PI
	


					renderer.render( scene, camera );
					// controls.update();
				});




			});


















//FULL GLTF CODE
//   const fov = 515;
//   const aspect = 1;  // the canvas default
//   const near = 1;
//   const far = 0;
//   const newcamera = new THREE.PerspectiveCamera(fov, aspect, near, far);
//   newcamera.position.set(0, 1, 10);

// //   const controls = new OrbitControls(newcamera, scene);
// //   controls.target.set(0, 5, 0);
// //   controls.update();

//   const newscene = new THREE.Scene();
// //   newscene.background = new THREE.Color('black');

//   {
//     const planeSize = 40;

//     const loader = new THREE.TextureLoader();
//     // const texture = loader.load('https://threejs.org/manual/examples/resources/images/checker.png');
//     // texture.wrapS = THREE.RepeatWrapping;
//     // texture.wrapT = THREE.RepeatWrapping;
//     // texture.magFilter = THREE.NearestFilter;
//     const repeats = planeSize / 2;
//     // texture.repeat.set(repeats, repeats);

//     const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
//     const planeMat = new THREE.MeshPhongMaterial({
//     //   map: texture,
//       side: THREE.DoubleSide,
//     });
//     const mesh = new THREE.Mesh(planeGeo, planeMat);
//     mesh.rotation.x = Math.PI * -.5;
//     newscene.add(mesh);
//   }

//   {
//     const skyColor = 0xB1E1FF;  // light blue
//     const groundColor = 0xB97A20;  // brownish orange
//     const intensity = 1;
//     const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
//     newscene.add(light);
//   }

//   {
//     const color = 0xFFFFFF;
//     const intensity = 1;
//     const light = new THREE.DirectionalLight(color, intensity);
//     light.position.set(5, 10, 2);
//     newscene.add(light);
//     newscene.add(light.target);
//   }

//   function frameArea(sizeToFitOnScreen, boxSize, boxCenter, newcamera) {
//     const halfSizeToFitOnScreen = sizeToFitOnScreen * 4;
//     const halfFovY = THREE.MathUtils.degToRad(newcamera.fov * .5);
//     const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
//     // compute a unit vector that points in the direction the camera is now
//     // in the xz plane from the center of the box
//     const direction = (new THREE.Vector3())
//         .subVectors(newcamera.position, boxCenter)
//         .multiply(new THREE.Vector3(1, 0, 1))
//         .normalize();

//     // move the camera to a position distance units way from the center
//     // in whatever direction the camera was from the center already
//     newcamera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

//     // pick some near and far values for the frustum that
//     // will contain the box.
//     newcamera.near = boxSize / 100;
//     newcamera.far = boxSize * 100;

//     newcamera.updateProjectionMatrix();

//     // point the camera to look at the center of the box
//     newcamera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
//   }

//   {
//     const gltfLoader = new GLTFLoader();
//     gltfLoader.load('/data/untitled.glb', (gltf) => {
//       const root = gltf.scene;
//       newscene.add(root);
// 	  console.log('new:', gltf)

//       // compute the box that contains all the stuff
//       // from root and below
//       const box = new THREE.Box3().setFromObject(root);

//       const boxSize = box.getSize(new THREE.Vector3()).length();
//       const boxCenter = box.getCenter(new THREE.Vector3());

//       // set the camera to frame the box
//       frameArea(boxSize * 0.5, boxSize, boxCenter, newcamera);

	 

//       // update the Trackball controls to handle the new size
//     //   controls.maxDistance = boxSize * 10;
//     //   controls.target.copy(boxCenter);
//     //   controls.update();
//     });
//   }



// newrenderer = new THREE.WebGLRenderer( { alpha: true } );
// newrenderer.setSize( window.innerWidth, window.innerHeight );
// document.body.appendChild( newrenderer.domElement );

// function animate() {
//   requestAnimationFrame( animate );
//   newrenderer.render( newscene, newcamera );

// }
// animate()
// newrenderer.render( newscene, newcamera );

		</script>
	</body>
	
</html>
